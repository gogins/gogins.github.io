<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../">
  <title data-ice="title">public/csoundac.mjs</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  <script src="script/manual.js"></script>
</head>
<body class="layout-container" data-ice="rootContainer">

<header>
  <a href="./">Home</a>
  
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
</header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  <li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/public/CsoundAudioNode.js~CsoundAudioNode.html">CsoundAudioNode</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/public/csoundac.mjs~ChordPatterns.html">ChordPatterns</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/public/csoundac.mjs~PitvPatterns.html">PitvPatterns</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/public/csoundac.mjs~ScalePatterns.html">ScalePatterns</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/public/statefulpatterns.mjs~StatefulPatterns.html">StatefulPatterns</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-Chord">Chord</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-Clone">Clone</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-Pitv">Pitv</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-Scale">Scale</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-frequencyToMidiInteger">frequencyToMidiInteger</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-frequencyToMidiReal">frequencyToMidiReal</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-getFrequency">getFrequency</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-hsvToRgb">hsvToRgb</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-print_counter">print_counter</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-setPitch">setPitch</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-set_instrument_count">set_instrument_count</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-track">track</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-diagnostic">diagnostic</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-diagnostic_level">diagnostic_level</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-audioContext">audioContext</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-chordn_counter">chordn_counter</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-csound">csound</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-csoundac">csoundac</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-csoundn">csoundn</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-csoundn_counter">csoundn_counter</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-instrument_count">instrument_count</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-ALWAYS">ALWAYS</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-DEBUG">DEBUG</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-ERROR">ERROR</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-INFORMATION">INFORMATION</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-NEVER">NEVER</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-WARNING">WARNING</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-audioContext">audioContext</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-csound">csound</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-csoundac">csoundac</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-diagnostic_level_">diagnostic_level_</a></span></span></li>
</ul>
</div>
</nav>

<div class="content" data-ice="content"><h1 data-ice="title">public/csoundac.mjs</h1>
<pre class="source-code line-number raw-source-code"><code class="prettyprint linenums" data-ice="content">/**
 * C S O U N D A C   M O D U L E   F O R   S T R U D E L
 *
 * Author: Michael Gogins
 * 
 * [csound-ac](https://github.com/gogins/csound-ac), or CsoundAC, is a C++ 
 * algorithmic composition library designed for use with Csound.
 *
 * [csound-wasm](https://github.com/gogins/csound-wasm) is a WebAssembly 
 * library containing both Csound and CsoundAC, with a JavaScript API, 
 * designed for use in Web browsers and npm applications.
 *
 * This module brings chords and scales, and operations upon them, 
 * from the CsoundAC library for algorithmic composition into the 
 * Strudel (Tidal Cycles-based) JavaScript pattern language. This is 
 * done by deriving from the StatefulPatterns class new classes whose 
 * member functions become Patterns.
 *
 * Another use of StatefulPatterns is to define algorithmic note generators, 
 * often driven by a `pure` pattern that acts as a clock.
 *
 * Please note, however, that this module, although it defines a number of 
 * Patterns, is not built into Strudel and is designed to be dynamically 
 * imported in patches created by users in the Strudel REPL. Therefore, code 
 * in this module, as with all other modules directly imported in code 
 * run by the Strudel REPL, must not use template strings.
 */
let csound = globalThis.__csound__;
let csoundac = globalThis.__csoundac__;
let audioContext = new AudioContext();

import {diagnostic, diagnostic_level, ALWAYS, DEBUG, INFORMATION, WARNING, ERROR, NEVER, StatefulPatterns} from &apos;../statefulpatterns.mjs&apos;;
export {diagnostic, diagnostic_level, ALWAYS, DEBUG, INFORMATION, WARNING, ERROR, NEVER, StatefulPatterns};

/**
 * Similar to `arrange,` but permits a section to be silenced by setting its 
 * number of cycles to 0; `sections` is an array of arrays, in the format 
 * `[[cycles, Pattern],...]`. Useful for assembling Patterns into longer-form 
 * compositions.
 */
export function track(...sections) {
    sections = sections.filter(function(element) {
        return element[0] &gt;= 1;
    });
    const total = sections.reduce((sum, [cycles]) =&gt; sum + cycles, 0);
    sections = sections.map(([cycles, section]) =&gt; [cycles, section.fast(cycles)]);
    return timeCat(...sections).slow(total);
};

/**
 * Returns the frequency corresponding to any of various ways that pitch 
 * is represented in Strudel events.
 */
const getFrequency = (hap) =&gt; {
    let {
        value,
        context
    } = hap;
    // if value is number =&gt; interpret as midi number as long as its not marked as frequency
    if (typeof value === &apos;object&apos;) {
        if (value.freq) {
            return value.freq;
        }
        return getFreq(value.note || value.n || value.value);
    }
    if (typeof value === &apos;number&apos; &amp;&amp; context.type !== &apos;frequency&apos;) {
        value = midiToFreq(hap.value);
    } else if (typeof value === &apos;string&apos; &amp;&amp; isNote(value)) {
        value = midiToFreq(noteToMidi(hap.value));
    } else if (typeof value !== &apos;number&apos;) {
        throw new Error(&apos;not a note or frequency: &apos; + value);
    }
    return value;
};

/**
 * A utility that assigns a pitch represented as a MIDI key number to the Hap, 
 * using the existing pitch property if it exists.
 */
export function setPitch(hap, midi_key) {
    if (typeof hap.value === &apos;undefined&apos;) {
        hap.value = midi_key;
    } else if (typeof hap.value === &apos;object&apos;) {
        if (typeof hap.value.freq !== &apos;undefined&apos;) {
            hap.value.freq = midiToFreq(midi_key);
        } else if (typeof hap.value.note !== &apos;undefined&apos;) {
            hap.value.note = midi_key;
        } else if (typeof hap.value.n !== &apos;undefined&apos;) {
            hap.value.n = midi_key;
        }
    } else {
        // Number or string all get the MIDI key.
        hap.value = midi_key;
    } 
    return hap;
}

/**
 * A utility that returns the MIDI key number for a frequency in Hz, 
 * as a real number allowing fractions for microtones.
 */
export function frequencyToMidiReal(frequency) {
    const middle_c = 261.62558;
    let octave_ = Math.log(frequency / middle_c) / Math.log(2.) + 8.;
    let midi_key = octave_ * 12. - 36.;
    return midi_key;
}

/**
 * A utility that returns the MIDI key number for a frequency in Hz, 
 * as the nearest integer.
 */
export function frequencyToMidiInteger(frequency) {
    let midi_key = frequencyToMidiReal(frequency);
    return Math.round(midi_key);
}

/**
 * A utility for making a _value_ copy of a Chord (or a Scale, which 
 * is derived from Chord). Object b is resized to the size of a, and a&apos;s 
 * pitches are copied to b. Currently, only pitches are copied.
 */
export function Clone(a, b) {
    b.resize(a.voices())
    for (let voice = 0; voice &lt; a.voices(); ++voice) {
        let a_pitch = a.getPitch(voice);
        let b_pitch = b.getPitch(voice);
        b.setPitch(voice, a_pitch);
        if (diagnostic_level() &gt;= DEBUG) registerPatterns([&apos;[voice &apos;, voice, &apos;a:&apos;, a_pitch, &apos;old b:&apos;, b_pitch, &apos;new b:&apos;, b.getPitch(voice), &apos;\n&apos;].join(&apos; &apos;));
    }
}

export function print_counter(pattern, counter, value) {
    if (value.constructor.name === &apos;Hap&apos;) {
        diagnostic(&apos;[&apos; + pattern + &apos;] sync: counter: &apos; + counter + &apos; value: &apos; + value.show() + &apos;\n&apos;, ALWAYS);
    } else if (value.constructor.name === &apos;Chord&apos;) {
        diagnostic(&apos;[&apos; + pattern + &apos;] sync: counter: &apos; + counter + &apos; value: &apos; + value.toString() + &apos;\n&apos;, ALWAYS);
    } else {
        diagnostic(&apos;[&apos; + pattern + &apos;] sync: counter: &apos; + counter + &apos; value: &apos; + value + &apos;\n&apos;, ALWAYS);
    }
}

let instrument_count = 10;

export function set_instrument_count(new_count) {
    let old_count = instrument_count;
    instrument_count = new_count;
    return old_count;
}

export function hsvToRgb(h,s,v) {
  var rgb, i, data = [];
  if (s === 0) {
    rgb = [v,v,v];
  } else {
    h = h / 60;
    i = Math.floor(h);
    data = [v*(1-s), v*(1-s*(h-i)), v*(1-s*(1-(h-i)))];
    switch(i) {
      case 0:
        rgb = [v, data[2], data[0]];
        break;
      case 1:
        rgb = [data[1], v, data[0]];
        break;
      case 2:
        rgb = [data[0], v, data[2]];
        break;
      case 3:
        rgb = [data[0], data[1], v];
        break;
      case 4:
        rgb = [data[2], data[0], v];
        break;
      default:
        rgb = [v, data[0], data[1]];
        break;
    }
  }
  return &apos;#&apos; + rgb.map(function(x){ 
    return (&apos;0a&apos; + Math.round(x*255).toString(16)).slice(-2);
  }).join(&apos;&apos;);
};

let csoundn_counter = 0;

/**
 * Sends notes to Csound for rendering with MIDI semantics. The Hap value is
 * translated to Csound pfields as follows:
 *
 *  p1 -- Csound instrument either as a number (1-based, can be a fraction),
 *        or as a string name.
 *  p2 -- time in beats (usually seconds) from start of performance.
 *  p3 -- duration in beats (usually seconds).
 *  p4 -- MIDI key number from Strudel&apos;s Hap value (as a real number, not an 
 *        integer, in [0, 127].
 *  p5 -- MIDI velocity from Strudel&apos;s `gain` control (as a real number, not 
 *        an integer, in [0, 127].
 *  p6 -- Spatial depth dimension, from a `depth` control, defaulting to 0.
 *  p7 -- Spatial pan dimension, from Strudel&apos;s `pan` control, in [0, 1],
 *        defaulting to 0.5.
 *  p8 -- Spatial height dimension, from a `height` control, defaulting to 0.
 */
export const csoundn = register(&apos;csoundn&apos;, (instrument, pat) =&gt; {
    let p1;
    if (typeof instrument === &apos;string&apos;) {
        p1 = &apos;\&quot;&apos; + instrument + &apos;\&quot;&apos;;
    } else {
        p1 = instrument;
    }
    return pat.onTrigger((tidal_time, hap) =&gt; {
        try {
            if (!csound) {
              diagnostic(&apos;[csoundn]: Csound is not yet loaded.\n&apos;, WARNING);
              return;
            }
            // Time in seconds counting from now.
            let p2 = tidal_time - getAudioContext().currentTime;
            if (p2 &lt; 0) {
                p2 = 0;
            }
            const p3 = hap.duration.valueOf() + 0;
            const frequency = getFrequency(hap);
            // Translate frequency to MIDI key number _without_ rounding.
            const C4 = 261.62558;
            let octave = Math.log(frequency / C4) / Math.log(2.0) + 8.0;
            const p4 = octave * 12.0 - 36.0;
            // We prefer floating point precision, but over the MIDI range [0, 127].
            ///const p5 = 127 * (hap.context?.velocity ?? 0.9);
            let gain;
            if (typeof hap.value.gain === &apos;undefined&apos;) {
                gain = .9;
            } else {
                gain = hap.value.gain;
            }
            let p5 = 127 * gain;
            let p6;
            if (typeof hap.value.depth === &apos;undefined&apos;) {
                p6 = 0;
            } else {
                p6 = hap.value.depth;
            }
            let p7;
            if (typeof hap.value.pan === &apos;undefined&apos;) {
                p7 = 0;
            } else {
                p7 = hap.value.pan;
            }
            let p8;
            if (typeof hap.value.height === &apos;undefined&apos;) {
                p8 = 0;
            } else {
                p8 = hap.value.depth;
            }
            const i_statement = [&apos;i&apos;, p1, p2, p3, p4, p5, p6, p7, p8, &apos;\n&apos;].join(&apos; &apos;);
            console.log(&apos;[csoundn] &apos; + i_statement);
            csound.readScore(i_statement);
            // Any controls in the Hap that start with &apos;gi&apos; or &apos;gk&apos; will be 
            // treated as Csound control channels, and their values will be 
            // sent to Csound. Normally, these channels have been defined in 
            // the Csound orchestra code.
            for (let control in hap.value) {
                if (control.startsWith(&apos;gi&apos;) || control.startsWith(&apos;gk&apos;)) {
                    csound.SetControlChannel(control, parseFloat(hap.value[control]));
                }
            }
            csoundn_counter = csoundn_counter + 1;
            if ((diagnostic_level() &gt;= INFORMATION) === true) {
                print_counter(&apos;csoundn&apos;, csoundn_counter, hap);
            }
            // Color the event by both insno and gain.
            // insno is hue, and gain is value, in HSV.
            if (globalThis.haps_from_outputs) {
                if (typeof hap.value !== &apos;object&apos;) {
                    hap.value = {note: p4, gain: gain};
                } else {
                    hap.value.note = p4;
                    hap.value.gain = gain;
                }
                hap.value.color = hsvToRgb((p1 / instrument_count) * 360, 1, gain);
                globalThis.haps_from_outputs.push(hap);
            }
        } catch (except) {
            diagnostic(&apos;[csoundn] error: &apos; + except + &apos;\n&apos;, ERROR);
        }
    });
});

let chordn_counter = 0;

/**
 * Creates and initializes a CsoundAC Chord object. This function should be 
 * called from module scope in Strudel code before creating any Patterns. The 
 * Chord class is based on Dmitri Tymoczko&apos;s model of chord space, and 
 * represents an equally tempered chord of the specified number of voices as 
 * a single point in chord space, where each dimension of the space 
 * corresponds to one voice of the Chord. Chords are equipped with numerous 
 * operations from pragmatic music theory, atonal music theory, and 
 * neo-Riemannian music theory.
 */
export function Chord(name) {
    if (diagnostic_level() &gt;= DEBUG) diagnostic(&apos;[csacChord] Creating Chord...\n&apos;);
    let chord_ = csoundac.chordForName(name);
    if (diagnostic_level() &gt;= DEBUG) diagnostic(&apos;[csacChord]:&apos; + chord_.toString() + &apos;\n&apos;);
    return chord_;
}

/**
 * Creates and initializes a CsoundAC Scale object. This function can be 
 * called from module scope in Strudel code before creating any Patterns. The 
 * Scale class is derived from the CsoundAC Chord class, but has been 
 * equipped with additional methods based on Dimitri Tymoczko&apos;s model of 
 * functional harmony. This enables algorithmically generating Chords from 
 * scale degrees, transposing Chords by scale degrees, generating all 
 * possible modulations given a pivot chord, and implementing secondary 
 * dominants and tonicizations based on scale degree.
 */
export function Scale(name) {
    name = name.replace(&apos;_&apos;, &apos; &apos;);
    if (diagnostic_level() &gt;= DEBUG) diagnostic(&apos;[Scale] Creating Scale...\n&apos;);
    let scale_ = csoundac.scaleForName(name);
    if (diagnostic_level() &gt;= DEBUG) diagnostic(&apos;[Scale] &apos; + scale_.name() + &apos;\n&apos;);
    return scale_;
}

/**
 * Creates and initializes a CsoundAC PITV object. This function should be 
 * called from module scope in Strudel code before creating any Patterns. The 
 * PITV object is a 4 dimensional cyclic group whose dimensions are TI set 
 * class (P), chord inversion (I), pitch-class transposition (T), and index 
 * of octavewise revoicing within the specified range (V). The elements of 
 * the group are chords in 12 tone equal temperament with the specified 
 * number of voices. There is a one-to-one mapping between PITV indices and 
 * chords, such that each voiced chord corresponds to a PITV index, and each 
 * PITV index corresponds to a voiced chord. This enables algorithmically 
 * generating harmonies and voicings by independently varying P, I, T, and V.
 */
export function Pitv(voices, bass, range) {
    if (diagnostic_level() &gt;= DEBUG) diagnostic(&apos;[Pitv] Creating PITV group...\n&apos;);
    let pitv = new csoundac.PITV();
    pitv.bass = bass;
    pitv.initialize(voices, range, 1., false);
    pitv.P = 0;
    pitv.I = 0;
    pitv.T = 0;
    pitv.V = 0;
    pitv.list(true, false, false);
    return pitv;
}

/**
 * Creates a class to hold state, and defines Patterns for creating and using 
 * that state to work with CsoundAC Chords. An instance of this class must be 
 * created at module scope and passed to the relevant Patterns.
 *
 * Some hacks are used to co-ordinate state with triggers:
 *  - Assume that chord changes happen only once at any given time.
 *  - In the trigger, apply the input to the Pattern if and only if the input 
 *    is different from the old input.
 */
export class ChordPatterns extends StatefulPatterns {
    constructor(chord, modality) {
        super();
        this.registerPatterns();
        if (typeof chord === &apos;string&apos;) {
            this.ac_chord = csoundac.chordForName(chord);
            if (diagnostic_level() &gt;= DEBUG) diagnostic(&apos;[ChordPatterns] created new chord.\n&apos;);
        } else {
            this.ac_chord = chord;            if (diagnostic_level() &gt;= DEBUG) diagnostic(&apos;[ChordPatterns] using existing chord.\n&apos;);
        }
        if (typeof modality == &apos;undefined&apos;) {
            this.ac_modality = this.ac_chord;
        } else {
            this.ac_modality = modality;
        }
        this.prior_chord = this.ac_chord;
        this.value = 0;
        this.acC_counter = 0;
        this.acC_chord_string = null;
        this.acCT_counter = 0;
        this.acCT_semitones = null
        this.acCI_counter = 0;
        this.acCI_center = null;
        this.acCK_counter = 0;
        this.acCK_state = null;
        this.acCQ_counter = 0;
        this.acCQ_semitones = null;
        this.acCOP_counter = 0;
        this.acCRP_counter = 0;
        this.acCO_counter = 0;
        this.acCV_counter = 0;
        this.acCVV_counter = 0;
        this.acCVVL_counter = 0;
    }
    /**
     * Applies a Chord or chord name to this.
     */
    acC(is_onset, chord_id, hap) {
        if (is_onset === true) {
            if (typeof chord_id === &apos;string&apos;) {
                this.ac_chord = csoundac.chordForName(chord_id);
                if (diagnostic_level() &gt;= DEBUG) diagnostic(&apos;[acC onset] created new Chord.\n&apos;);
            } else {
                this.ac_scale = scale;
                if (diagnostic_level() &gt;= DEBUG) diagnostic(&apos;[acC onset] using existing Chord.\n&apos;);
            }
            if (this.acS_chord_string != this.ac_chord.toString()) {
                this.acS_chord_string = this.ac_chord.toString();
                this.ac_chord = this.ac_scale.chord(1, this.voices, 3);
                if (diagnostic_level() &gt;= WARNING) {
                    diagnostic([&apos;[acS onset] new Chord:&apos;, this.ac_chord.toString(), this.ac_chord.name(), &apos;\n&apos;].join(&apos; &apos;));
                 }
                this.acC_counter = this.acC_counter + 1;
                if (diagnostic_level() &gt;= INFORMATION) {
                    print_counter(&apos;acC&apos;, this.acC_counter, hap);
                }
            }
        }
        return hap;
    }
    /**
     * Applies a transposition to the Chord of this.
     */
    acCT(is_onset, semitones, hap) {
        if (is_onset === true) {
            if (this.acCT_semitones != semitones) {
                this.acCT_semitones = semitones;
                if (diagnostic_level() &gt;= DEBUG) diagnostic([&apos;[acCT onset] current chord:    &apos;, this.ac_chord.toString(), this.ac_chord.eOP().name(), hap.show(), &apos;\n&apos;].join(&apos; &apos;));
                this.ac_chord = this.ac_chord.T(semitones);
                if (diagnostic_level() &gt;= WARNING) diagnostic([&apos;[acCT onset] transformed chord:&apos;, this.ac_chord.toString(), this.ac_chord.eOP().name(), hap.show(), &apos;\n&apos;].join(&apos; &apos;));
                this.acCT_counter = this.acCT_counter + 1;
                if (diagnostic_level() &gt;= INFORMATION) {
                    print_counter(&apos;acCT&apos;, this.acCT_counter, hap);
                }
            }
        }
        return hap;
    }
    /**
     * Applies an inversion to the Chord of this. The transformation can be 
     * patternified with a Pattern of flips (changes in the value of the flip 
     * input).
     */
    acCI(is_onset, center, flip, hap) {
        if (is_onset === true) {
            if (this.acCI_flip != flip) {
                this.acCI_flip = flip;
                if (diagnostic_level() &gt;= DEBUG) diagnostic([&apos;[acCI] onset: current chord:    &apos;, this.ac_chord.toString(), this.ac_chord.eOP().name(), hap.show(), &apos;\n&apos;].join(&apos; &apos;));
                this.ac_chord = this.ac_chord.I(center);
                if (diagnostic_level() &gt;= WARNING) diagnostic([&apos;[acCI] onset: transformed chord:&apos;, this.ac_chord.toString(), this.ac_chord.eOP().name(), hap.show(), &apos;\n&apos;].join(&apos; &apos;));
                this.acCI_counter = this.acCI_counter + 1;
                if (diagnostic_level() &gt;= INFORMATION) {
                    print_counter(&apos;acCI&apos;, this.acCI_counter, hap);
                }
            }
        }
        return hap;
    }
    /**
     * Applies the interchange by inversion operation of the Generalized 
     * Contextual Group of Fiore and Satyendra to the Chord of this. The 
     * transformation can be patternified with a Pattern of flips (changes in 
     * the value of the flip input).
     */
    acCK(is_onset, flip, hap) {
        if (is_onset === true) {
            if (this.flip != flip) {
                this.flip = flip;
                if (diagnostic_level() &gt;= DEBUG) diagnostic([&apos;[acCK onset] current chord:    &apos;, this.ac_chord.toString(), this.ac_chord.eOP().name(), hap.show(), &apos;\n&apos;].join(&apos; &apos;));
                this.ac_chord = this.ac_chord.K();
                if (diagnostic_level() &gt;= WARNING) diagnostic([&apos;[acCK onset] transformed chord:&apos;, this.ac_chord.toString(), this.ac_chord.eOP().name(), hap.show(), &apos;\n&apos;].join(&apos; &apos;));
                this.acCK_counter = this.acCK_counter + 1;
                if (diagnostic_level() &gt;= INFORMATION) {
                    print_counter(&apos;acCK&apos;, this.acCK_counter, hap);
                }
            }
        }
        return hap;
    }
    /**
     * Applies the contexual transposition operation of the Generalized 
     * Contextual Group of Fiore and Satyendra to the Chord of this. The 
     * modality is set in the constructor of this class.
     */
     acCQ(is_onset, semitones, hap) {
        if (is_onset === true) {
            if (diagnostic_level() &gt;= DEBUG) diagnostic([&apos;[acCQ onset] current chord:    &apos;, this.ac_chord.toString(), this.ac_chord.eOP().name(), hap.show(), &apos;\n&apos;].join(&apos; &apos;));
            this.ac_chord = this.ac_chord.Q(semitones, this.ac_modality, 1);
            if (diagnostic_level() &gt;= WARNING) diagnostic([&apos;[acCQ onset] transformed chord:&apos;, this.ac_chord.toString(), this.ac_chord.eOP().name(), hap.show(), &apos;\n&apos;].join(&apos; &apos;));
            this.acCQ_counter = this.acCQ_counter + 1;
            if (diagnostic_level() &gt;= INFORMATION) {
                print_counter(&apos;acCQ&apos;, this.acCQ_counter, hap);
            }
        }
        return hap;
    }
    /**
     * Transforms the Chord of this to its &apos;OP&apos; form; &apos;chord&apos; is an extremely 
     * flexible and therefore ambiguous term, but the &apos;OP&apos; form is what most 
     * musicians usually mean by &apos;chord&apos;: A chord where the octaves of the 
     * pitches do not matter and the order of the voices does not matter. This 
     * transformation can be useful for returning chords that have been 
     * transformed such that their voices are out of range back to a more 
     * normal form.
     */
    acCOP(is_onset, hap) {
        if (is_onset === true) {
            if (diagnostic_level() &gt;= DEBUG) diagnostic([&apos;[acCOP onset] current chord:    &apos;, this.ac_chord.toString(), this.ac_chord.eOP().name(), hap.show(), &apos;\n&apos;].join(&apos; &apos;));
            this.ac_chord = this.ac_chord.eOP();
            if (diagnostic_level() &gt;= WARNING) diagnostic([&apos;[acCOP onset] transformed chord:&apos;, this.ac_chord.toString(), this.ac_chord.eOP().name(), hap.show(), &apos;\n&apos;].join(&apos; &apos;));
            this.acCOP_counter = this.acCOP_counter + 1;
            if (diagnostic_level() &gt;= INFORMATION) {
                print_counter(&apos;acCOP&apos;, this.acCOP_counter, hap);
            }
        }
        return hap;
    }
    /**
     * Transforms the Chord of this to its &apos;RP&apos; form; &apos;chord&apos; is an extremely 
     * flexible and therefore ambiguous term, but the &apos;RP&apos; form is a chord 
     * where the octaves are folded within the indicated range, and like &apos;OP&apos;
     * the order of the voices does not matter. This 
     * transformation can be useful for returning chords that have been 
     * transformed such that their voices are out of range back to a user-
     * defined range.
     */
    acCRP(is_onset, range, hap) {
        if (is_onset === true) {
            if (diagnostic_level() &gt;= DEBUG) diagnostic([&apos;[acCRP onset] current chord:    &apos;, this.ac_chord.toString(), this.ac_chord.eOP().name(), hap.show(), &apos;\n&apos;].join(&apos; &apos;));
            this.ac_chord = this.ac_chord.eRP(range);
            if (diagnostic_level() &gt;= WARNING) diagnostic([&apos;[acCRP onset] transformed chord:&apos;, this.ac_chord.toString(), this.ac_chord.eOP().name(), hap.show(), &apos;\n&apos;].join(&apos; &apos;));
            this.acCRP_counter = this.acCRP_counter + 1;
            if (diagnostic_level() &gt;= INFORMATION) {
                print_counter(&apos;acCRP&apos;, this.acCRP_counter, hap);
            }
        }
        return hap;
    }    
    /**
     * Applies the Chord of this to the _pitch-class_ of the Hap, i.e., moves 
     * the _pitch-class_ of the Hap to the nearest _pitch-class_ of the Chord.
     */
    acCV(is_onset, hap) {
        if (is_onset === true) {
            let frequency;
            try {
                frequency = getFrequency(hap);
            } catch (error) {
                diagnostic(&apos;[acCV value]: not a note!\n&apos;);
                return;
            }
            let current_midi_key = frequencyToMidiInteger(frequency);
            let epcs = this.ac_chord.epcs();
            if (diagnostic_level() &gt;= DEBUG) diagnostic([&apos;[acCV value] current chord:  &apos;, this.ac_chord.toString(), this.ac_chord.eOP().name(), &apos;\n&apos;].join(&apos; &apos;));
            if (diagnostic_level() &gt;= DEBUG) diagnostic([&apos;[acCV value] current hap:    &apos;, hap.show(), &apos;\n&apos;].join(&apos; &apos;));
            let note = csoundac.conformToPitchClassSet(current_midi_key, epcs);
            hap = setPitch(hap, note);
            ChordPatterns.acCV_counter = ChordPatterns.acCV_counter + 1;
            if (diagnostic_level() &gt;= WARNING) diagnostic([&apos;[acCV value] new hap:        &apos;, hap.show(), &apos;\n&apos;].join(&apos; &apos;));   
            if (diagnostic_level() &gt;= INFORMATION) {
                print_counter(&apos;acCV onset&apos;, ChordPatterns.acCV_counter, hap);
            }
        } else {
            let frequency;
            try {
                frequency = getFrequency(hap);
            } catch (error) {
                diagnostic(&apos;[acCV value]: not a note!\n&apos;);
                return;
            }
            let current_midi_key = frequencyToMidiInteger(frequency);
            let epcs = this.ac_chord.epcs();
            if (diagnostic_level() &gt;= DEBUG) diagnostic([&apos;[acCV value] current chord:  &apos;, this.ac_chord.toString(), this.ac_chord.eOP().name(), &apos;\n&apos;].join(&apos; &apos;));
            if (diagnostic_level() &gt;= DEBUG) diagnostic([&apos;[acCV value] current hap:    &apos;, hap.show(), &apos;\n&apos;].join(&apos; &apos;));
            let note = csoundac.conformToPitchClassSet(current_midi_key, epcs);
            hap = setPitch(hap, note);
            //~ if (diagnostic_level() &gt;= DEBUG) diagnostic([&apos;[acCV value] new hap:        &apos;, hap.show(), &apos;\n&apos;].join(&apos; &apos;));
            //~ if (diagnostic_level() &gt;= INFORMATION) {
                //~ print_counter(&apos;acCV value&apos;, ChordPatterns.acCV_counter, hap);
            //~ }
        }
        return hap;
    }

    /**  
     * acCO:      Transforms the Chord of this by the indicated number of 
     *            octavewise revoicings: negative means subtract an octave 
     *            from the highest voice, positive means add an octave to the 
     *            lowest voice. This corresponds to the musician&apos;s notion of 
     *            &quot;inversion.&quot;
     */
    acCO(is_onset, revoicings, hap) {
        if (is_onset) {
            if (diagnostic_level() &gt;= DEBUG) diagnostic([&apos;[acCO] onset: current chord:    &apos;, this.ac_chord.toString(), this.ac_chord.eOP().name(), hap.show(), &apos;\n&apos;].join(&apos; &apos;));
            this.ac_chord = this.ac_chord.v(revoicings);
            if (diagnostic_level() &gt;= WARNING) diagnostic([&apos;[acCO] onset: transformed chord:&apos;, this.ac_chord.toString(), this.ac_chord.eOP().name(), hap.show(), &apos;\n&apos;].join(&apos; &apos;));
            this.acCO_counter = this.acCO_counter + 1;
            if (diagnostic_level() &gt;= INFORMATION) {
                print_counter(&apos;acCO&apos;, this.acCO_counter, hap);
            }
            this.prior_chord = this.ac_chord;  
        }
        return hap;       
    }
    
    /**
     * acCVV:      Generate a note that represents a particular voice of the 
     *             Chord.
     */
    acCVV(is_onset, bass, voice, hap) {
        let new_midi_key = bass + this.ac_chord.getPitch(voice);
        hap = setPitch(hap, new_midi_key);
        if (diagnostic_level() &gt;= DEBUG) diagnostic([&apos;[acCVV value]:&apos;, &apos;new_midi_key:&apos;, new_midi_key, &apos;new note:&apos;, hap.show(), &apos;\n&apos;].join(&apos; &apos;));
        this.prior_chord = this.ac_chord;  
        return hap;
    }
    /**
     * acCVVL:     Generate a note that represents a particular voice of the 
     *             Chord, as the closest voice-leading from the prior Chord.
     */
    acCVVL(is_onset, bass, range, voice, hap) {
        if (this.prior_chord != this.ac_chord) {
            let new_chord = csoundac.voiceleadingClosestRange(this.prior_chord, this.ac_chord, range, true);
            const message = [&apos;[acCVVL]:&apos;, &apos;\n  prior_chord: &apos;, this.prior_chord.toString(), &apos;\n  ac_chord:    &apos;, this.ac_chord.toString(), &apos;\n  new ac_chord:&apos;,new_chord.toString() + &apos;\n&apos;].join(&apos; &apos;);
            if (diagnostic_level() &gt;= DEBUG) diagnostic(message);
            console.log(message);
            this.ac_chord = new_chord;
        }
        let new_midi_key = bass + this.ac_chord.getPitch(voice);
        hap = setPitch(hap, new_midi_key);
        if (diagnostic_level() &gt;= DEBUG) diagnostic([&apos;[acCVVL value]:&apos;, &apos;new_midi_key:&apos;, new_midi_key, &apos;new note:&apos;, hap.show(), &apos;\n&apos;].join(&apos; &apos;));
        this.prior_chord = this.ac_chord;  
        return hap;
    }
}

/**
 * Creates a class to hold state, and defines Patterns for creating and using 
 * that state to work with CsoundAC Scales. An instance of this class must be 
 * created at module scope and passed to the relevant Patterns. The 
 * constructor sets the number of voices in Chords associated with the Scale,
 * by default 4.
 *
 * State is co-ordinated with the triggers of the Patterns by only updating 
 * the state when the input of the Pattern changes.
*/
export class ScalePatterns extends StatefulPatterns {
    constructor(scale, voices = 3) {
        super();
        this.registerPatterns();
        this.voices = voices;
        if (typeof scale === &apos;string&apos;) {
            // Have to use underscores instead of spaces in the Strudel REPL.
            scale = scale.replace(&apos;_&apos;, &apos; &apos;);
            this.ac_scale = csoundac.scaleForName(scale);
            if (diagnostic_level() &gt;= WARNING) diagnostic(&apos;[acS onset] created new scale.\n&apos;);
        } else {
            this.ac_scale = scale;
            if (diagnostic_level() &gt;= DEBUG) diagnostic(&apos;[acS onset] using existing scale.\n&apos;);
        }
        this.ac_chord = this.ac_scale.chord(1, this.voices, 3);
        this.prior_chord = this.ac_chord;
        this.acS_counter = 0;
        this.acS_scale_string = null;
        this.acSS_counter = 0;
        this.acSS_scale_step = null;
        this.acST_counter = 0;
        this.acST_scale_steps = null;
        this.acSM_counter = 0;
        this.acSM_index = null;
        this.acSO_counter = 0;
        this.acSV_counter = 0;
        this.acSCV_counter = 0;
 
    }
    /**
     * acS:        Insert a CsoundAC Scale into the Pattern&apos;s state.
     */
    acS(is_onset, scale, hap) {
        if (is_onset === true) {
            if (typeof scale === &apos;string&apos;) {
                // Have to use underscores instead of spaces in the Strudel REPL.
                scale = scale.replace(&apos;_&apos;, &apos; &apos;);
                this.ac_scale = csoundac.scaleForName(scale);
                if (diagnostic_level() &gt;= DEBUG) diagnostic(&apos;[acS onset] created new scale.\n&apos;);
            } else {
                this.ac_scale = scale;
                if (diagnostic_level() &gt;= DEBUG) diagnostic(&apos;[acS onset] using existing scale.\n&apos;);
            }
            if (this.acS_scale_string != this.ac_scale.toString()) {
                this.acS_scale_string = this.ac_scale.toString();
                this.ac_chord = this.ac_scale.chord(1, this.voices, 3);
                if (diagnostic_level() &gt;= WARNING) {
                    diagnostic([&apos;[acS onset] new scale:&apos;, this.ac_scale.toString(), this.ac_scale.name(), &apos;\n&apos;].join(&apos; &apos;));
                    diagnostic([&apos;[acS onset] new chord:&apos;, this.ac_chord.toString(), this.ac_chord.name(), &apos;\n&apos;].join(&apos; &apos;));
                }
                this.acS_counter = this.acS_counter + 1;
                if (diagnostic_level() &gt;= INFORMATION) {
                    print_counter(&apos;acS&apos;, this.acS_counter, hap);
                }
            }
        }
        return hap;
    }
    /** 
     * acSS:       Insert the Chord at the specified scale step of the Scale in 
     *             the Pattern&apos;s state, into the state.
     */
    acSS(is_onset, scale_step, hap) {
        if (is_onset === true) {
            if (this.acSS_scale_step != scale_step) {
                this.acSS_scale_step = scale_step;
                if (diagnostic_level() &gt;= DEBUG) diagnostic([&apos;[acSS onset] current chord:    &apos;, this.ac_chord.toString(), this.ac_chord.eOP().name(), &apos;\n&apos;].join(&apos; &apos;));
                this.ac_chord = this.ac_scale.chord(scale_step, this.voices, 3);
                if (diagnostic_level() &gt;= WARNING) diagnostic([&apos;[acSS onset] transformed chord:&apos;, this.ac_chord.toString(), this.ac_chord.eOP().name(), &apos;\n&apos;].join(&apos; &apos;));
                this.acSS_counter = this.acSS_counter + 1;
                if (diagnostic_level() &gt;= INFORMATION) {
                    print_counter(&apos;acSS&apos;, this.acSS_counter, hap);
                }
            }
        }  
        return hap;
    }
    /**
     * acST:       Transpose the Chord in the Pattern&apos;s state by the specified 
     *             number of scale steps in the Scale in the state.
     */
    acST(is_onset, scale_steps, hap) {
        if (is_onset === true) {
            if (this.acST_scale_steps != scale_steps) {
                this.acST_scale_steps = scale_steps;
                if (diagnostic_level() &gt;= WARNING) diagnostic([&apos;[acST onset] current chord:    &apos;, this.ac_chord.toString(), this.ac_chord.eOP().name(), &apos;\n&apos;].join(&apos; &apos;));
                this.ac_chord = this.ac_scale.transpose_degrees(this.ac_chord, scale_steps, 3);    
                if (diagnostic_level() &gt;= WARNING) diagnostic([&apos;[acST onset] transformed chord:&apos;, this.ac_chord.toString(), this.ac_chord.eOP().name(), &apos;\n&apos;].join(&apos; &apos;));
                this.acST_counter = this.acST_counter + 1;
                if (diagnostic_level() &gt;= INFORMATION) {
                    print_counter(&apos;acST&apos;, this.acST_counter, hap);
                }
            }
        }
        return hap;
    }
    /**
     * acSM:       Modulate from the Scale in the Pattern&apos;s state, using the 
     *             Chord in the state as a pivot, choosing one of the possible 
     *             modulations by index.
     */
    acSM(is_onset, index, hap) {
        if (is_onset === true) {
             if (this.acSM_index != index) {
                this.acSM_index = index;
                let pivot_chord_eop = this.ac_chord.eOP();
                let possible_modulations = this.ac_scale.modulations(pivot_chord_eop);
                let new_scale = this.ac_scale;
                let modulation_count = possible_modulations.size();
                let wrapped_index = -1;
                if (modulation_count &gt; 0) {
                    wrapped_index = index % modulation_count;
                    new_scale = possible_modulations.get(wrapped_index);
                    if (diagnostic_level() &gt;= WARNING) {
                        diagnostic(&apos;[acSM onset] modulating in: &apos; + this.ac_scale.toString() + &apos; &apos; + this.ac_scale.name() + &apos;\n&apos;);
                        diagnostic(&apos;[acSM onset] from pivot:    &apos; + pivot_chord_eop.toString(), + &apos; &apos; + pivot_chord_eop.name() + &apos;\n&apos;);
                        diagnostic(&apos;[acSM onset] modulations:   &apos; + modulation_count + &apos; =&gt; &apos; + wrapped_index + &apos;\n&apos;);
                        diagnostic(&apos;[acSM onset] modulated to:  &apos; + new_scale.toString() + &apos; &apos; + new_scale.name() + &apos;\n&apos;);
                        diagnostic(&apos;[acSM onset] hap:           &apos; + hap.show() + &apos;\n&apos;);
                    }
                    this.ac_scale = new_scale;
                }
                this.acSM_counter = this.acSM_counter + 1;
                if (diagnostic_level() &gt;= INFORMATION) {
                    print_counter(&apos;acSM&apos;, this.acSM_counter, hap);
                }
            }
        }
        return hap;
    }
    /**
     * acSV:       Move notes in the Pattern to fit the Scale in the Pattern&apos;s 
     *             state.
     */
    acSV(is_onset, hap) {
        if (is_onset === true) {
            let frequency;
            try {
                frequency = getFrequency(hap);
            } catch (error) {
                diagnostic(&apos;[acSV value] not a note!\n&apos;);
                return;
            }
            let current_midi_key = frequencyToMidiInteger(frequency);
            let epcs = this.ac_scale.epcs();
            if (diagnostic_level() &gt;= DEBUG) diagnostic([&apos;[acSV value] current scale:  &apos;, this.ac_scale.toString(), this.ac_scale.eOP().name(), &apos;\n&apos;].join(&apos; &apos;));
            if (diagnostic_level() &gt;= DEBUG) diagnostic([&apos;[acSV value] current hap:    &apos;, hap.show(), &apos;\n&apos;].join(&apos; &apos;));
            let note = csoundac.conformToPitchClassSet(current_midi_key, epcs);
            hap = setPitch(hap, note);
            if (diagnostic_level() &gt;= WARNING) diagnostic([&apos;[acSV value] new hap:        &apos;, hap.show(), &apos;\n&apos;].join(&apos; &apos;));
            this.acSV_counter = this.acSV_counter + 1;
            if (diagnostic_level() &gt;= INFORMATION) {
                print_counter(&apos;acSV&apos;, this.acSV_counter, hap);
            }
        } else {
            let frequency;
            try {
                frequency = getFrequency(hap);
            } catch (error) {
                diagnostic(&apos;[acSV value] not a note!\n&apos;);
                return;
            }
            let current_midi_key = frequencyToMidiInteger(frequency);
            let epcs = this.ac_scale.epcs();
            if (diagnostic_level() &gt;= DEBUG) diagnostic([&apos;[acSV value] current scale:  &apos;, this.ac_scale.toString(), this.ac_scale.eOP().name(), &apos;\n&apos;].join(&apos; &apos;));
            if (diagnostic_level() &gt;= DEBUG) diagnostic([&apos;[acSV value] current hap:    &apos;, hap.show(), &apos;\n&apos;].join(&apos; &apos;));
            let note = csoundac.conformToPitchClassSet(current_midi_key, epcs);
            hap = setPitch(hap, note);
            if (diagnostic_level() &gt;= DEBUG) diagnostic([&apos;[acSV value] new hap:        &apos;, hap.show(), &apos;\n&apos;].join(&apos; &apos;));
        }
        return hap;
    }
    /**
     * acSCV:      Move notes in the Pattern to fit the Chord in the Pattern&apos;s 
     *             state.
     */
    acSCV(is_onset, hap) {
        if (is_onset === true) {
            let frequency;
            try {
                frequency = getFrequency(hap);
            } catch (error) {
                diagnostic(&apos;[acSCV value] not a note!\n&apos;);
                return;
            }
            let current_midi_key = frequencyToMidiInteger(frequency);
            let epcs = this.ac_chord.epcs();
            if (diagnostic_level() &gt;= DEBUG) diagnostic([&apos;[acSCV onset] current scale:  &apos;, this.ac_scale.toString(), this.ac_scale.eOP().name(), &apos;\n&apos;].join(&apos; &apos;));
            if (diagnostic_level() &gt;= DEBUG) diagnostic([&apos;[acSCV onset] current chord:  &apos;, this.ac_chord.toString(), this.ac_chord.eOP().name(), &apos;\n&apos;].join(&apos; &apos;));
            if (diagnostic_level() &gt;= DEBUG) diagnostic([&apos;[acSCV onset] current hap:    &apos;, hap.show(), &apos;\n&apos;].join(&apos; &apos;));
            let note = csoundac.conformToPitchClassSet(current_midi_key, epcs);
            hap = setPitch(hap, note);
            if (diagnostic_level() &gt;= WARNING) diagnostic([&apos;[acSCV onset] new hap:        &apos;, hap.show(), &apos;\n&apos;].join(&apos; &apos;));
            this.acSCV_counter = this.acSCV_counter + 1;
            if (diagnostic_level() &gt;= INFORMATION) {
                print_counter(&apos;acSCV&apos;, this.acSCV_counter, hap);
            }
        } else {
            let frequency;
            try {
                frequency = getFrequency(hap);
            } catch (error) {
                diagnostic(&apos;[acSCV value] not a note!\n&apos;);
                return;
            }
            let current_midi_key = frequencyToMidiInteger(frequency);
            let epcs = this.ac_chord.epcs();
            if (diagnostic_level() &gt;= DEBUG) diagnostic([&apos;[acSCV value] current scale:  &apos;, this.ac_scale.toString(), this.ac_scale.eOP().name(), &apos;\n&apos;].join(&apos; &apos;));
            if (diagnostic_level() &gt;= DEBUG) diagnostic([&apos;[acSCV value] current chord:  &apos;, this.ac_chord.toString(), this.ac_chord.eOP().name(), &apos;\n&apos;].join(&apos; &apos;));
            if (diagnostic_level() &gt;= DEBUG) diagnostic([&apos;[acSCV value] current hap:    &apos;, hap.show(), &apos;\n&apos;].join(&apos; &apos;));
            let note = csoundac.conformToPitchClassSet(current_midi_key, epcs);
            hap = setPitch(hap, note);
            if (diagnostic_level() &gt;= DEBUG) diagnostic([&apos;[acSCV value] new hap:        &apos;, hap.show(), &apos;\n&apos;].join(&apos; &apos;));
            this.acSCV_counter = this.acSCV_counter + 1;
         }
        return hap;
    }
    /**  
     * acSO:      Transforms the Chord of this by the indicated number of 
     *            octavewise revoicings: negative means subtract an octave 
     *            from the highest voice, positive means add an octave to the 
     *            lowest voice. This corresponds to the musician&apos;s notion of 
     *            &quot;inversion.&quot;
     */
    acSO(is_onset, revoicings, hap) {
        if (is_onset) {
            if (diagnostic_level() &gt;= DEBUG) diagnostic([&apos;[acSO] onset: current chord:    &apos;, this.ac_chord.toString(), this.ac_chord.eOP().name(), hap.show(), &apos;\n&apos;].join(&apos; &apos;));
            this.ac_chord = this.ac_chord.v(revoicings);
            if (diagnostic_level() &gt;= WARNING) diagnostic([&apos;[acSO] onset: transformed chord:&apos;, this.ac_chord.toString(), this.ac_chord.eOP().name(), hap.show(), &apos;\n&apos;].join(&apos; &apos;));
            this.acSO_counter = this.acSO_counter + 1;
            if (diagnostic_level() &gt;= INFORMATION) {
                print_counter(&apos;acSO&apos;, this.acSO_counter, hap);
            }
            this.prior_chord = this.ac_chord;  
        }
        return hap;       
    }
    
        /**
     * acSVV:      Generate a note that represents a particular voice of the 
     *             Chord of this.
     */
    acCVV(is_onset, bass, voice, hap) {
        let new_midi_key = bass + this.ac_chord.getPitch(voice);
        hap = setPitch(hap, new_midi_key);
        if (diagnostic_level() &gt;= DEBUG) diagnostic([&apos;[acCVV value]:&apos;, &apos;new_midi_key:&apos;, new_midi_key, &apos;new note:&apos;, hap.show(), &apos;\n&apos;].join(&apos; &apos;));
        this.prior_chord = this.ac_chord;  
        return hap;
    }
    /**
     * acSVVL:     Generate a note that represents a particular voice of the 
     *             current Chord, as the closest voice-leading from the prior 
     *             Chord.
     */
    acSVVL(is_onset, bass, range, voice, hap) {
        if (this.prior_chord != this.ac_chord) {
            this.ac_chord = csoundac.voiceleadingClosestRange(this.prior_chord, this.ac_chord, range, true);
        }
        let new_midi_key = bass + this.ac_chord.getPitch(voice);
        hap = setPitch(hap, new_midi_key);
        if (diagnostic_level() &gt;= DEBUG) diagnostic([&apos;[acSVVL value]:&apos;, &apos;new_midi_key:&apos;, new_midi_key, &apos;new note:&apos;, hap.show(), &apos;\n&apos;].join(&apos; &apos;));
        this.prior_chord = this.ac_chord;  
        return hap;
    }}

/**
 * Creates a class to hold state and defines Patterns for creating and using 
 * that state to work with CsoundAC PITV groups. An instance of this class 
 * must be created at module scope and passed to the relevant Patterns.
 */
export class PitvPatterns extends StatefulPatterns {
    constructor(pitv) {
        super();
        this.registerPatterns();
        this.prior_chord = null;
        this.pitv = pitv;
        this.acPP_counter = 0;
        this.acPP_P = null;
        this.acPI_counter = 0;
        this.acPI_I = null;
        this.acPT_counter = 0;
        this.acPT_T = null;
        this.acPV_counter = 0;
        this.acPV_V = null;
        this.acPO_counter = 0;
        this.acPO_value = null;
        this.acPC_counter = 0;
        this.acPVS_counter = 0;
        this.acPVV_counter = 0;
    }
    /**
     * acP:        Insert a CsoundAC PITV group into the Pattern&apos;s state.
     */
    acP(is_onset, pitv, hap) {
        if (is_onset == true) {
            if (diagnostic_level() &gt;= DEBUG) diagnostic([&apos;[acP onset] current PITV:  &apos;, this.this.pitv.list(true, true, false), &apos;\n&apos;].join(&apos; &apos;));
            this.pitv = pitv;
            this.acP_counter = this.acP_counter + 1;
            if (diagnostic_level() &gt;= INFORMATION) {
                print_counter(&apos;acP&apos;, this.acP_counter, hap);
            }
        } 
        return hap;
    }
    /**
     * acPP:       Set the prime form index of the PITV element in the Pattern&apos;s 
     *             state.
     */
    acPP(is_onset, P, hap) {
        if (is_onset === true) {
            if (this.acPP_P != P) {
                this.acPP_P = P;
                this.pitv.P = P;
                this.acPP_counter = this.acPP_counter + 1;
                if (diagnostic_level() &gt;= INFORMATION) {
                    print_counter(&apos;acPP&apos;, this.acPP_counter, hap);
                }
            }
        }
        return hap;
    }

    static acPI_counter = 1;

    /**
     * acPI:       Set the inversion index of the PITV element in the Pattern&apos;s 
     *             state.
     */
    acPI(is_onset, I, hap) {
        if (is_onset === true) {
            if (this.acPI_I != I) {
                this.acPI_I = I;
                this.pitv.I = I;
                this.acPI_counter = this.acPI_counter + 1;
                if (diagnostic_level() &gt;= INFORMATION) {
                    print_counter(&apos;acPI&apos;, this.acPI_counter, hap);
                }
            }
        }
        return hap;
    }
    /**
     * acPT:       Set the transposition index of the PITV element in the 
     *             Pattern&apos;s state.
     */
    acPT(is_onset, T, hap) {
        if (is_onset === true) {
            if (this.acPT_T != T) {
                this.acPT_T = T;
                this.pitv.T = T;
                this.acPT_counter = this.acPT_counter + 1;
                if (diagnostic_level() &gt;= INFORMATION) {
                    print_counter(&apos;acPT&apos;, this.acPT_counter, hap);
                }
            }
        }
        return hap;
    }
    /**
     * acPO:       Set the octavewise voicing index of the PITV element in the 
     *             Pattern&apos;s state.
     */
    acPO(is_onset, V, hap) {
        if (is_onset == true) {
            if (this.acPO_O != V) {
                this.acPO_O = V;
                this.pitv.V = V;
                this.acPO_counter = this.acPO_counter + 1;
                if (diagnostic_level() &gt;= INFORMATION) {
                    print_counter(&apos;acPO&apos;, this.acPO_counter, hap);
                }
            }
        }
        return hap;
    }
    /**
     * acPC:       Insert the Chord corresponding to the PITV element into the 
     *             Pattern&apos;s state.
     */
    acPC(is_onset, hap) {
        if (is_onset === true) {
            this.ac_chord = this.pitv.toChord(this.pitv.P, this.pitv.I, this.pitv.T, this.pitv.V, true).get(0);
            if (diagnostic_level() &gt;= WARNING) diagnostic([&apos;[acPC onset]:&apos;, this.ac_chord.toString(), this.ac_chord.eOP().name(), &apos;\n&apos;].join(&apos; &apos;));
            this.acPC_counter = this.acPC_counter + 1;
            if (diagnostic_level() &gt;= INFORMATION) {
                print_counter(&apos;acPC&apos;, this.acPC_counter, hap);
            }
        }
        return hap;
    }
    /**
     * acPV:       Move notes in the Pattern to fit the pitch-class set of the 
     *             element of the PITV group in the Pattern&apos;s state.
     */
    acPV(is_onset, hap) {
        let frequency;
        try {
            frequency = getFrequency(hap);
        } catch (error) {
            diagnostic(&apos;[acPV] not a note!\n&apos;, WARNING);
            return;
        }
        let current_midi_key = frequencyToMidiInteger(frequency);
        let result = this.pitv.toChord(this.pitv.P, this.pitv.I, this.pitv.T, this.pitv.V, true);
        let eop = result.get(1);
        let epcs = eop.epcs();
        let new_midi_key = csoundac.conformToPitchClassSet(current_midi_key, epcs);
        hap = setPitch(hap, new_midi_key);
        if (diagnostic_level() &gt;= DEBUG) diagnostic([&apos;[acPV value]:&apos;, eop.toString(), eop.name(), &apos;old note:&apos;, current_midi_key, &apos;new note:&apos;, hap.show(), &apos;\n&apos;].join(&apos; &apos;));
        this.prior_chord = result.get(0);
        return hap;
    }
    /**
     * acPVV:      Generate a note that represents a particular voice of the 
     *             Chord.
     */
    acPVV(is_onset, voice, hap) {
        let voiced_chord = this.pitv.toChord(this.pitv.P, this.pitv.I, this.pitv.T, this.pitv.V, true).get(0);
        let new_midi_key = voiced_chord.getPitch(voice) + this.pitv.bass;
        hap = setPitch(hap, new_midi_key);
        if (diagnostic_level() &gt;= DEBUG) diagnostic([&apos;[acPVV value]:&apos;, &apos;new_midi_key:&apos;, new_midi_key, &apos;new note:&apos;, hap.show(), &apos;\n&apos;].join(&apos; &apos;));
        this.prior_chord = voiced_chord;
        return hap;
    }    
    /**
     * acPVVL:     Generate a note that represents a particular voice of the 
     *             Chord, as the closest voice-leading from the prior element of this.
     */
   acPVVL(is_onset, voice, hap) {
       this.ac_chord = this.pitv.toChord(this.pitv.P, this.pitv.I, this.pitv.T, this.pitv.V, true).get(0);
       if (this.prior_chord != this.ac_chord) {
            this.ac_chord = csoundac.voiceleadingClosestRange(this.prior_chord, this.ac_chord, range, true);
       }
       let new_midi_key = this.ac_chord.getPitch(voice) + this.pitv.bass;
       hap = setPitch(hap, new_midi_key);
       if (diagnostic_level() &gt;= DEBUG) diagnostic([&apos;[acPVVL value]:&apos;, &apos;new_midi_key:&apos;, new_midi_key, &apos;new note:&apos;, hap.show(), &apos;\n&apos;].join(&apos; &apos;));
       this.prior_chord = this.ac_chord;
       return hap;
   }
}



</code></pre>

</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(1.1.0)</span><img src="./image/esdoc-logo-mini-black.png"></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
