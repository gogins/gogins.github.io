{"version":3,"file":"clockworker-ZDiUtESR.js","sources":["../../packages/core/clockworker.js"],"sourcesContent":["// eslint-disable-next-line no-undef\n// TODO: swap below line with above one when firefox supports esm imports in service workers\n// see https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorker?retiredLocale=de#browser_compatibility\n// import createClock from './zyklus.mjs';\n\nfunction getTime() {\n  const seconds = performance.now() * 0.001;\n  return seconds;\n  // return Math.round(seconds * precision) / precision;\n}\n\nlet num_cycles_at_cps_change = 0;\nlet num_ticks_since_cps_change = 0;\nlet num_seconds_at_cps_change = 0;\nlet cps = 0.5;\n// {id: {started: boolean}}\nconst clients = new Map();\nconst duration = 0.1;\nconst channel = new BroadcastChannel('strudeltick');\n\nconst sendMessage = (type, payload) => {\n  channel.postMessage({ type, payload });\n};\n\nconst sendTick = (phase, duration, tick, time) => {\n  const num_seconds_since_cps_change = num_ticks_since_cps_change * duration;\n  const tickdeadline = phase - time;\n  const lastTick = time + tickdeadline;\n  const num_cycles_since_cps_change = num_seconds_since_cps_change * cps;\n  const begin = num_cycles_at_cps_change + num_cycles_since_cps_change;\n  const secondsSinceLastTick = time - lastTick - duration;\n  const eventLength = duration * cps;\n  const end = begin + eventLength;\n  const cycle = begin + secondsSinceLastTick * cps;\n\n  sendMessage('tick', {\n    begin,\n    end,\n    cps,\n    time,\n    cycle,\n  });\n  num_ticks_since_cps_change++;\n};\n\n//create clock method from zyklus\nconst clock = createClock(getTime, sendTick, duration);\nlet started = false;\n\nconst startClock = (id) => {\n  clients.set(id, { started: true });\n  if (started) {\n    return;\n  }\n  clock.start();\n  started = true;\n};\nconst stopClock = async (id) => {\n  clients.set(id, { started: false });\n\n  const otherClientStarted = Array.from(clients.values()).some((c) => c.started);\n  //dont stop the clock if other instances are running...\n  if (!started || otherClientStarted) {\n    return;\n  }\n\n  clock.stop();\n  setCycle(0);\n  started = false;\n};\n\nconst setCycle = (cycle) => {\n  num_ticks_since_cps_change = 0;\n  num_cycles_at_cps_change = cycle;\n};\n\nconst processMessage = (message) => {\n  const { type, payload } = message;\n\n  switch (type) {\n    case 'cpschange': {\n      if (payload.cps !== cps) {\n        const num_seconds_since_cps_change = num_ticks_since_cps_change * duration;\n        num_cycles_at_cps_change = num_cycles_at_cps_change + num_seconds_since_cps_change * cps;\n        num_seconds_at_cps_change = num_seconds_at_cps_change + num_seconds_since_cps_change;\n        cps = payload.cps;\n        num_ticks_since_cps_change = 0;\n      }\n      break;\n    }\n    case 'setcycle': {\n      setCycle(payload.cycle);\n      break;\n    }\n    case 'toggle': {\n      if (payload.started) {\n        startClock(message.id);\n      } else {\n        stopClock(message.id);\n      }\n      break;\n    }\n  }\n};\n\nself.onconnect = function (e) {\n  // the incoming port\n  const port = e.ports[0];\n\n  port.addEventListener('message', function (e) {\n    processMessage(e.data);\n  });\n  port.start(); // Required when using addEventListener. Otherwise called implicitly by onmessage setter.\n};\n\n// used to consistently schedule events, for use in a service worker - see <https://github.com/tidalcycles/strudel/blob/main/packages/core/clockworker.mjs>\nfunction createClock(\n  getTime,\n  callback, // called slightly before each cycle\n  duration = 0.05, // duration of each cycle\n  interval = 0.1, // interval between callbacks\n  overlap = 0.1, // overlap between callbacks\n) {\n  let tick = 0; // counts callbacks\n  let phase = 0; // next callback time\n  let precision = 10 ** 4; // used to round phase\n  let minLatency = 0.01;\n  const setDuration = (setter) => (duration = setter(duration));\n  overlap = overlap || interval / 2;\n  const onTick = () => {\n    const t = getTime();\n    const lookahead = t + interval + overlap; // the time window for this tick\n    if (phase === 0) {\n      phase = t + minLatency;\n    }\n    // callback as long as we're inside the lookahead\n    while (phase < lookahead) {\n      phase = Math.round(phase * precision) / precision;\n      phase >= t && callback(phase, duration, tick, t);\n      phase < t && console.log('TOO LATE', phase); // what if latency is added from outside?\n      phase += duration; // increment phase by duration\n      tick++;\n    }\n  };\n  let intervalID;\n  const start = () => {\n    clear(); // just in case start was called more than once\n    onTick();\n    intervalID = setInterval(onTick, interval * 1000);\n  };\n  const clear = () => intervalID !== undefined && clearInterval(intervalID);\n  const pause = () => clear();\n  const stop = () => {\n    tick = 0;\n    phase = 0;\n    clear();\n  };\n  const getPhase = () => phase;\n  // setCallback\n  return { setDuration, start, stop, pause, duration, interval, getPhase, minLatency };\n}\n"],"names":["getTime","num_cycles_at_cps_change","num_ticks_since_cps_change","cps","clients","duration","channel","sendMessage","type","payload","clock","createClock","phase","tick","time","num_seconds_since_cps_change","tickdeadline","lastTick","num_cycles_since_cps_change","begin","secondsSinceLastTick","eventLength","end","cycle","started","startClock","id","stopClock","otherClientStarted","c","setCycle","processMessage","message","e","port","callback","interval","overlap","precision","minLatency","setDuration","setter","onTick","t","lookahead","intervalID","start","clear"],"mappings":"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"}